---
title: "Compute per-barcode escape"
author: "Tyler Starr"
date: "11/20/2020"
output:
  github_document:
    toc: true
    html_preview: false
editor_options: 
  chunk_output_type: inline
---

This notebook computes and summarizes per-barcode escape fractions for the homolog library variants.

```{r setup, message=FALSE, warning=FALSE, error=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = T)
knitr::opts_chunk$set(dev.args = list(png = list(type = "cairo")))

#list of packages to install/load
packages = c("yaml","data.table","tidyverse","gridExtra")
#install any packages not already installed
installed_packages <- packages %in% rownames(installed.packages())
if(any(installed_packages == F)){
  install.packages(packages[!installed_packages])
}
#load packages
invisible(lapply(packages, library, character.only=T))

#read in config file
config <- read_yaml("config.yaml")

#make output directory
if(!file.exists(config$escape_scores_dir)){
  dir.create(file.path(config$escape_scores_dir))
}
```
Session info for reproducing environment:
```{r print_sessionInfo}
sessionInfo()
```

## Setup

Read in table of variant genotypes and barcode counts in each sequencing sample, barcode-variant association table, and previously determined barcode-level expression measurements. Add variant sequence and expression information to the sequencing counts data table.

```{r input_data}
dt <- data.table(read.csv(file=config$variant_counts,stringsAsFactors = F))

bc_lookup <- data.table(read.csv(file=config$barcode_variant_table))

bc_expr <- data.table(read.csv(file=config$barcode_expression))

#add target and expression to dt table
dt <- merge(dt[,.(barcode,library,sample,count)],bc_lookup[,.(barcode,library,target)],by=c("library","barcode"))

dt <- merge(dt[,.(barcode,library,sample,count,target)],bc_expr[,.(barcode,library,ML_meanF)],by=c("library","barcode"))

#read dataframe with list of barcode runs and associated metainfo for calculating escape fracs
barcode_runs <- read.csv(file=config$barcode_runs,stringsAsFactors=F); barcode_runs <- subset(barcode_runs, select=-c(R1))
#rename frac_escape to Frac, to avoid confusion with escape_frac later on
barcode_runs$Frac <- barcode_runs$frac_escape

#add this info to the dt table
dt <- merge(dt[,.(library,target,barcode,ML_meanF,sample,count)],barcode_runs[,c("date","antibody","selection","sample","Frac","cells_sorted")],by=c("sample"))

```

We have some barcodes in this library that do not express -- we expect these to impact our escape fraction calculation, which relies on the fraction of RBD+ cells that escape antibody -- however, these non-expressing cells will be in the pre-count (because our library was not pre-RBD+ sorted), even though they are not in the RBD+ subset that are sampled for escape. Therefore, they can bias up escape fraction scores (in a systematic way, but still, makes it ugly that escape fractions are biased to be larger than the theoretical limit 1). Because they are not truly part of the "escape" experiment (filtered out by RBD+ gating), we remove them.

```{r filter_nonexpressing}
dt <- dt[ML_meanF > 7.5 | is.na(ML_meanF),]
```

## Calculating per-barcode escape score

Next, for each barcode at each of the ACE2 concentrations, calculate the "escape fraction", corresponding to the estimated fraction of cells with that barcode that were sorted into the antibody-escape bin. Escape fraciton for a variant (E_v) is equal to its post-sort frequency divided by its pre-sort frequency, multiplied by the big-F fraction, corresponding to the fraction of cells that were sorted into the antibody-escape bin.

```{r calculate_escape_frac}
#add big-N N_total_count, which corresponds to the sum of counts across all barcodes in a given sample (either pre or post selection)
dt[,N_total_count:=sum(count),by=c("library","sample")]

#post_freq for escape samples
dt[selection=="escape",post_freq:=count/N_total_count,by=c("library","sample","barcode")]

#pre_freq for reference samples
dt[selection=="reference",pre_freq:=count/N_total_count,by=c("library","sample","barcode")]

#for each escape sample, get the barcode pre_freq and pre_count from the corresponding date's reference sample
#define a function for vectorizing to pull out the associated pre-sort frequency
get_presort_freq_count <- function(day, lib, bc){
  return(list(dt[selection=="reference" & date==day & library==lib & barcode==bc,pre_freq],dt[selection=="reference" & date==day & library==lib & barcode==bc,count]))
}

#assign
dt[selection=="escape",c("pre_freq","pre_count"):=get_presort_freq_count(day=date,lib=library,bc=barcode),by=c("library","sample","barcode")]

#calculate escape frac
dt[selection=="escape",escape_frac:=Frac*post_freq/pre_freq]

```
These calculations took a while to compute, so let's output the summary table, and do post-calc analysis in a new notebook (so this doesn't have to be run every time we want to replot or change filtering)

## Data Output

```{r output_data}
dt <- dt[selection=="escape",]
dt[,post_count:=count]
dt[,expression:=ML_meanF]
dt[,.(library, target, barcode, expression, antibody, pre_count, post_count, pre_freq, post_freq, escape_frac)] %>%
  mutate_if(is.numeric, round, digits=5) %>%
  write.csv(file=config$escape_fracs_barcodes, row.names=F)

```





